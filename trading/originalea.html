<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
	<link rel="stylesheet" type="text/css" media="screen" href="../codestyles.css">
	<link rel="icon" type="image/x-icon" href="./images/trader.png">
    <title>Original Expert Advisor</title>
	<style>
@media screen 	
		{.container				{display: grid; grid-template-areas: "description description description description description description" "origin origin uploaded status status supplemental" "code code code code code code";}} 								
		
	</style>
    <script src="https://cdn.jsdelivr.net/npm/brython@3.9.5/brython.min.js"></script>
</head>
<body onload="brython()" class="codepage">
	<header>
		<div><a href="../index.html#trading"><img src="./images/back.png" alt="Back Arrow" title="Back Arrow"></a></div>
		<div><h1>Original Expert Advisor</h1></div>
	</header>
	<main class="container">
		<div class="description"><p><strong>Description:</strong> This was my attempt to write a trading program from scratch that incorporated all of the concepts of both my trading 
		knowledge and MQL5 into a single program. While I never got it to be profitable (unsurprisingly), there is some pride in writing something so ambitious compared to how 
		little I knew only months earlier and getting it at least part way off the ground.
		</p></div>
		<div class="origin"><p><strong>Original Creation:</strong> 3rd Nov 2023</p></div>
		<div class="uploaded"><p><strong>Uploaded:</strong> 14th Jun 2025</p></div>
		<div class="status"><p><strong>Status:</strong> Incomplete. Original code was written without AI.</p></div>
		<div class="supplemental"><p><strong>Supplemental:</strong> N/A </p></div>
	<div class="gallery">
	</div>	
	<div class="code">		
		<!-- <button onclick="Toggle()">Toggle Original Python Code Display</button> -->
		<button onclick="Copy()">Copy the MQL5 Code</button>
	
	<p id="pycode">
//If a breakout is too high, consider it a lost cause?<br>//If a second breakout does not reach at least X% of the first, consider it a lost cause?<br><br>// Ctrl + ; to uncomment lines <br>// Alt + 124 for vertical line |<br><br>#property strict<br>#include <Trade/Trade.mqh><br>CTrade Trader;<br>// Do not set backtest start date as: a) mid-March, b) end of October, or c) beginning of November!<br>// This is because DSDifference is set to false by default.<br>// Trading should not be allowed on Sundays<br>// The difference between Toronto time and server time is 7 h most of the year.<br>// However, between the 2nd Sunday of March and the last Sunday of March, the difference is 6 h.<br>// Between the last Sunday of October and the first Sunday of November, the difference is 6 h.<br><br>enum Directions<br>  {<br>   None = 0,<br>   Up = 1,<br>   Down = 2<br>  };<br><br>input group "Entry Conditions"<br>input double InpBreakOutMult = 1.00015; // BreakOut Multiplier. Level price x this = minimum price that must be reached for BreakOut Flag to trigger.<br>input double InpOuterReTraceMult = 1.00015; // Outer ReTrace Multiplier. Price must retrace to inside of this fraction of the price level.<br>input double InpInnerReTraceMult = 1.00030; // Inner ReTrace Multiplier. Price must retrace to outside of this fraction of the price level.<br>input double InpRegainOuter = 70; //After retrace, price must within this percent of the Breakout High/Low for valid entry.<br>input double InpRegainInner = 30; //After retrace, price must outside this percent of the Breakout High/Low for valid entry.<br><br>input group "Lots"<br>input double InpDollarAmount = 10; //Amount Per Position in Dollars<br>input double InpStopLossMult = 1.00030; // Determines how far away from retrace point to set stop loss<br><br>bool TradeAllowed;<br><br>double HighPivotPoints[];<br>double LowPivotPoints[];<br>double HighPivotPrice;<br>double PivotReTracePrice;<br>double PivotRegainTarget;<br>Directions PivotDirection;<br><br>bool BreakOutUpFlag;<br>bool BreakOutDownFlag;<br>bool ReTraceFlag;<br>bool PivotReTraceFlag;<br>bool EntryFlag;<br>bool ReTraceActivate;<br>int Timer;<br>int ReTraceBar;<br><br>double DayHigh;<br>double DayLow;<br>double TokyoHigh;<br>double TokyoLow;<br>double LondonHigh;<br>double LondonLow;<br>double NYHigh;<br>double NYLow;<br>double BreakOutHigh;<br>double BreakOutLow;<br><br>int Number;<br>int SundayCount;<br>int MaxSundays;<br>bool DSDifference;<br>int TokyoStartTime = 2*60;<br>int TokyoEndTime = 10*60; //London start time. This is based on UTC + 2<br>int LondonStartTime = 10*60; <br>int LondonEndTime = 15*60; //NY start time<br>int NYStartTime = 15*60;<br>int NYEndTime = 23*60 + 59;<br><br>//////////////////////////////////////////////////////////<br><br>int OnInit()<br>  {<br>   TradeAllowed = true;<br>  <br>   EventSetTimer(1200); //set to 20 minutes to give it multiple chances to work within 1 hour<br>   MaxSundays = 0;<br>   DSDifference = false; <br>   ArraySetAsSeries(HighPivotPoints, true);<br>   ArraySetAsSeries(LowPivotPoints, true);<br>   HighPivotPrice = 0;<br>   PivotReTracePrice = 0;<br>   PivotRegainTarget = 0;<br>   PivotDirection = None;<br>   <br>   DayHigh = 0;<br>   DayLow = 100000;<br>   TokyoHigh = 0;<br>   TokyoLow = 100000;<br>   LondonHigh = 0;<br>   LondonLow= 100000;<br>   NYHigh = 0;<br>   NYLow = 100000; <br>   BreakOutHigh = 0;<br>   BreakOutLow = 100000;<br>   <br>   BreakOutUpFlag = false;<br>   BreakOutDownFlag = false;<br>   ReTraceFlag = false;<br>   PivotReTraceFlag = false;<br>   EntryFlag = false;<br>   ReTraceActivate = false;<br>   Timer = 0;<br>   ReTraceBar = 0;<br>   <br>&nbsp;&nbsp;&nbsp;&nbsp;switch (Period())<br>&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PERIOD_M1:  Number=1;&nbsp;&nbsp;&nbsp;&nbsp; break; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PERIOD_M2:  Number=2;&nbsp;&nbsp;&nbsp;&nbsp; break; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PERIOD_M5:  Number=5;&nbsp;&nbsp;&nbsp;&nbsp; break; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PERIOD_M10: Number=10;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PERIOD_M15: Number=15;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PERIOD_M30: Number=30;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PERIOD_H1:  Number=60;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PERIOD_H4:  Number=240;   break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PERIOD_H6:  Number=360;   break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PERIOD_H8:  Number=480;   break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PERIOD_H12: Number=620;   break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Number=1440;  break;<br>&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;<br>   <br>   return(INIT_SUCCEEDED);<br>  }<br><br>void OnDeinit(const int reason)<br>  {<br>   EventKillTimer();   <br>  }<br><br>void OnTimer()<br>  {<br>   DSChecker();<br>//   Print("DSDifference: ", DSDifference);<br>   HighLowResetter();<br>//Print("DayHigh: ", DayHigh, " DayLow: ", DayLow, <br>//" TokyoHigh: ", TokyoHigh, " TokyoLow: ", TokyoLow,<br>//" LondonHigh: ", LondonHigh, " LondonLow: ", LondonLow,<br>//" NYHigh: ", NYHigh, " NYLow: ", NYLow);  <br>  } <br><br><br>///////////////////////////////////////////////////////////////////////////////////<br><br>void OnTick()<br>  {<br>  <br>  if(PositionsTotal() != 0)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp; for(int i=0;i<PositionsTotal();i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PositionGetTicket(i);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double NewSL = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double PosProf = PositionGetDouble(POSITION_PROFIT);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double PosOpen = PositionGetDouble(POSITION_PRICE_OPEN);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double PosSL = PositionGetDouble(POSITION_SL);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double PosVol = PositionGetDouble(POSITION_VOLUME);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double OrigSL = MathAbs(((0.00001*InpDollarAmount)/PosVol)-PosOpen);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double PosDiff = MathAbs(PosOpen-OrigSL); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int RGained = (int)MathFloor(PosProf/InpDollarAmount);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(RGained > 0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   NewSL =  NormalizeDouble(PosOpen + (RGained-1)*PosDiff, 5);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   if(NewSL > PosSL)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Print("Current SL: ", PosSL, " New SL: ", NewSL);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Trader.PositionModify(PositionGetTicket(i), NewSL, 0);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_SELL)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   NewSL =  NormalizeDouble(PosOpen - (RGained-1)*PosDiff, 5);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   if(NewSL < PosSL)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Print("Current SL: ", PosSL, " New SL: ", NewSL);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Trader.PositionModify(PositionGetTicket(i), NewSL, 0);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;  }<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;  <br>   //if(AccountInfoDouble(ACCOUNT_EQUITY) > (AccountInfoDouble(ACCOUNT_BALANCE) + 10000))<br>   //  {<br>   //   CloseAll();<br>   //  }<br>   <br>   //if(HourMQL4()==23 && MinuteMQL4()==59)<br>   //  {<br>   //   CloseAll();<br>   //  }<br><br><br>  if (SecondsMQL4() == 0) //okay to use in this case, as if there are no ticks, then high/low price hasn't changed<br>   { <br>   <br>   if(DSDifference)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp; LondonEndTime = 14*60;<br>&nbsp;&nbsp;&nbsp;&nbsp; NYStartTime = 14*60;<br>&nbsp;&nbsp;&nbsp;&nbsp; NYEndTime = 22*60 + 59;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>  else<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp; LondonEndTime = 15*60;<br>&nbsp;&nbsp;&nbsp;&nbsp; NYStartTime = 15*60;<br>&nbsp;&nbsp;&nbsp;&nbsp; NYEndTime = 23*60 + 59;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>  int DayMinutes = HourMQL4()*60 + MinuteMQL4(); <br>   <br>   //Print("LondonHigh: ", LondonHigh, " LondonLow: ", LondonLow);<br>&nbsp;&nbsp;&nbsp;&nbsp;if(DayMinutes > Number) <br>&nbsp;&nbsp;&nbsp;&nbsp;  {<br>&nbsp;&nbsp;&nbsp;&nbsp;   HighLow(DayHigh, DayLow);<br>//&nbsp;&nbsp;&nbsp;&nbsp;   Print("High: ", DayHigh, " Low: ", DayLow, " DayDiff: ", (DayHigh-DayLow));<br>&nbsp;&nbsp;&nbsp;&nbsp;  }<br>&nbsp;&nbsp;&nbsp;&nbsp;if(DayMinutes > Number && DayMinutes <= TokyoEndTime)<br>&nbsp;&nbsp;&nbsp;&nbsp;  {<br>&nbsp;&nbsp;&nbsp;&nbsp;   HighLow(TokyoHigh, TokyoLow);<br>//&nbsp;&nbsp;&nbsp;&nbsp;   Print("TokyoHigh: ", TokyoHigh, " TokyoLow: ", TokyoLow, " TokyoDiff: ", (TokyoHigh-TokyoLow));<br>&nbsp;&nbsp;&nbsp;&nbsp;  }<br>&nbsp;&nbsp;&nbsp;&nbsp;if(DayMinutes > LondonStartTime && DayMinutes <= LondonEndTime)<br>&nbsp;&nbsp;&nbsp;&nbsp;  {<br>&nbsp;&nbsp;&nbsp;&nbsp;   HighLow(LondonHigh, LondonLow);<br>&nbsp;&nbsp;&nbsp;&nbsp;   //Print("LondonHigh: ", LondonHigh, " LondonLow: ", LondonLow, " LondonDiff: ", (LondonHigh-LondonLow));<br>&nbsp;&nbsp;&nbsp;&nbsp;  }<br>&nbsp;&nbsp;&nbsp;&nbsp;if(DayMinutes > NYStartTime && DayMinutes <= NYEndTime)<br>&nbsp;&nbsp;&nbsp;&nbsp;  {<br>&nbsp;&nbsp;&nbsp;&nbsp;   HighLow(NYHigh, NYLow);<br>//&nbsp;&nbsp;&nbsp;&nbsp;   Print("NYHigh: ", NYHigh, " NYLow: ", NYLow, " NYDiff: ", (NYHigh-NYLow));<br>&nbsp;&nbsp;&nbsp;&nbsp;   if(!BreakOutUpFlag && !BreakOutDownFlag)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  BreakOut(BreakOutUpFlag, BreakOutDownFlag, LondonHigh, LondonLow, BreakOutHigh, BreakOutLow); //check the previous bar to see if price has broken out of London range<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;   if(BreakOutUpFlag || BreakOutDownFlag)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ReTraceReady(ReTraceActivate, DayMinutes, Number, Timer); //if a breakout has occurred, waits one bar before checking for a retrace<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;   if(ReTraceActivate)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ReTrace(LondonHigh, LondonLow, BreakOutUpFlag, BreakOutDownFlag, ReTraceFlag, ReTraceActivate, Timer, BreakOutHigh, BreakOutLow); //checks for a retrace, or a violation of a retrace<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp; //Print("BreakOutUpFlag: ", BreakOutUpFlag, " BreakOutDownFlag :", BreakOutDownFlag, " ReTraceFlag: ", ReTraceFlag, " ReTraceActivate: ", ReTraceActivate);<br>&nbsp;&nbsp;&nbsp;&nbsp;  }<br>&nbsp;&nbsp;&nbsp;&nbsp; if(DayMinutes > NYStartTime) //Pivot point detection<br>&nbsp;&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PivotPointDetection();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(!ReTraceFlag && !PivotReTraceFlag)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int i=0;i<ArraySize(HighPivotPoints);i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(HighPivotPoints[i] != DayHigh)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  double HighPivot = HighPivotPoints[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  double UpHighRetraceLim = HighPivot*InpOuterReTraceMult;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  double UpLowRetraceLim = 2*HighPivot - HighPivot*InpInnerReTraceMult;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if(BarLow(1) <= UpHighRetraceLim && BarLow(1) >= UpLowRetraceLim)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PivotReTraceFlag = true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PivotReTracePrice = HighPivot;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PivotRegainTarget = DayHigh;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PivotDirection = Up;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Print("Pivot Retrace Detected, Direction Up. Retrace Price: ", PivotReTracePrice, " Regain Target: ", PivotRegainTarget);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   }  <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int i=0;i<ArraySize(LowPivotPoints);i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   if(LowPivotPoints[i] != DayLow)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  double LowPivot = LowPivotPoints[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  double DownHighRetraceLim = LowPivot*InpInnerReTraceMult;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  double DownLowRetraceLim = 2*LowPivot - LowPivot*InpOuterReTraceMult;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if(BarHigh(1) >= DownLowRetraceLim && BarHigh(1) <= DownHighRetraceLim)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PivotReTraceFlag = true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PivotReTracePrice = LowPivot;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PivotRegainTarget = DayLow;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PivotDirection = Down;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Print("Pivot Retrace Detected, Direction Down. Retrace Price: ", PivotReTracePrice, " Regain Target: ", PivotRegainTarget);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  } <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   }  <br>&nbsp;&nbsp;&nbsp;&nbsp;   } //Pivot Point section ends<br>&nbsp;&nbsp;&nbsp;&nbsp;} //On New Bar section ends<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>   if(ReTraceFlag) //setting entry flag if retrace has occurred and price has regained a certain percent of the breakout max/min price<br>&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;  MqlTick tick;<br>&nbsp;&nbsp;&nbsp;&nbsp;  SymbolInfoTick(_Symbol, tick); //yes, this line is necessary<br>&nbsp;&nbsp;&nbsp;&nbsp;  double Bid = tick.bid;<br>&nbsp;&nbsp;&nbsp;&nbsp;  double Ask = tick.ask;<br>&nbsp;&nbsp;&nbsp;&nbsp;  if(BreakOutUpFlag)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double BOLHighDiff = BreakOutHigh - LondonHigh;<br>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Print("BreakOutHigh: ", BreakOutHigh, " BreakOutLow: ", BreakOutLow);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double RegainUpHighLimit = ((InpRegainOuter/100)*BOLHighDiff)+LondonHigh;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double RegainUpLowLimit = ((InpRegainInner/100)*BOLHighDiff)+LondonHigh;<br>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Print("Ask: ", Ask, " RegainUpHighLimit: ", RegainUpHighLimit, " RegainUpLowLimit: ", RegainUpLowLimit, " CurrBarOpen: ", CurrBarOpen);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(Ask >= RegainUpLowLimit && Ask <= RegainUpHighLimit && Ask > BarOpen(0))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EntryFlag = true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;  if(BreakOutDownFlag)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double BOLLowDiff = LondonLow - BreakOutLow;<br> //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Print("BreakOutHigh: ", BreakOutHigh, " BreakOutLow: ", BreakOutLow);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double RegainDownHighLimit = LondonLow-((InpRegainInner/100)*BOLLowDiff);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double RegainDownLowLimit = LondonLow-((InpRegainOuter/100)*BOLLowDiff);<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp; Print("Bid: ", Bid, " RegainDownHighLimit: ", RegainDownHighLimit, " RegainDownLowLimit: ", RegainDownLowLimit, " CurrBarOpen: ", CurrBarOpen);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(Bid >= RegainDownLowLimit && Bid <= RegainDownHighLimit && Bid < BarOpen(0))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EntryFlag = true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp; <br>   if(PivotReTraceFlag)<br>&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;  MqlTick tick;<br>&nbsp;&nbsp;&nbsp;&nbsp;  SymbolInfoTick(_Symbol, tick); //yes, this line is necessary<br>&nbsp;&nbsp;&nbsp;&nbsp;  double Bid = tick.bid;<br>&nbsp;&nbsp;&nbsp;&nbsp;  double Ask = tick.ask;<br>&nbsp;&nbsp;&nbsp;&nbsp;  <br>&nbsp;&nbsp;&nbsp;&nbsp;  if(PivotDirection == Up)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double PivotDiff = PivotRegainTarget-PivotReTracePrice;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double LowRetraceLim = 2*PivotReTracePrice - PivotReTracePrice*InpInnerReTraceMult;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double RegainUpHighLimit = ((InpRegainOuter/100)*PivotDiff)+PivotReTracePrice;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double RegainUpLowLimit = ((InpRegainInner/100)*PivotDiff)+PivotReTracePrice;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(Ask < LowRetraceLim)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PivotReTraceFlag = false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PivotDirection = None;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(Ask >= RegainUpLowLimit && Ask <= RegainUpHighLimit)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EntryFlag = true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;  if(PivotDirection == Down)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double PivotDiff = PivotReTracePrice-PivotRegainTarget;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double HighReTraceLim = PivotReTracePrice*InpInnerReTraceMult;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double RegainDownHighLimit = PivotReTracePrice-((InpRegainInner/100)*PivotDiff);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double RegainDownLowLimit = PivotReTracePrice-((InpRegainOuter/100)*PivotDiff);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(Bid > HighReTraceLim)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PivotReTraceFlag = false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PivotDirection = None;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(Bid >= RegainDownLowLimit && Bid <= RegainDownHighLimit)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EntryFlag = true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>   if(EntryFlag && TradeAllowed)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Print("EntryFlag: ", EntryFlag);&nbsp;&nbsp;&nbsp;&nbsp;  <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MqlTick tick;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SymbolInfoTick(_Symbol, tick); //yes, this line is necessary<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double Bid = tick.bid;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double Ask = tick.ask;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double entryprice, stoploss = 0, volume;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENUM_ORDER_TYPE ordertype;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(BreakOutUpFlag == true || PivotDirection == Up)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entryprice = Ask;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ordertype = ORDER_TYPE_BUY;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(BreakOutUpFlag == true)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   stoploss = 2*LondonHigh-(LondonHigh*InpStopLossMult);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(PivotDirection == Up)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   stoploss = 2*PivotReTracePrice-(PivotReTracePrice*InpStopLossMult);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;volume = NormalizeDouble(0.00001*InpDollarAmount/(entryprice-stoploss), 2);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool success = Trader.PositionOpen(_Symbol, ordertype, volume, entryprice, stoploss, 0);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(BreakOutDownFlag == true || PivotDirection == Down)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entryprice = Bid;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ordertype = ORDER_TYPE_SELL;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(BreakOutDownFlag == true)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   stoploss = LondonLow*InpStopLossMult;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(PivotDirection == Down)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   stoploss = PivotReTracePrice*InpStopLossMult;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;volume = NormalizeDouble(0.00001*InpDollarAmount/(stoploss-entryprice), 2);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool success = Trader.PositionOpen(_Symbol, ordertype, volume, entryprice, stoploss, 0);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EntryFlag = false;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BreakOutUpFlag = false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BreakOutDownFlag = false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReTraceFlag = false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReTraceActivate = false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PivotReTraceFlag = false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PivotReTracePrice = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PivotRegainTarget = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PivotDirection = None;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Timer = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BreakOutHigh = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BreakOutLow = 1000000;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;//if(HourMQL4() == 23 && MinuteMQL4() == 30 && SecondsMQL4() == 0)<br>&nbsp;&nbsp;&nbsp;&nbsp;//  {<br>&nbsp;&nbsp;&nbsp;&nbsp;   //Print("DayHigh: ", DayHigh, " DayLow: ", DayLow, " DayDiff: ", NormalizeDouble((DayHigh-DayLow), 5), <br>&nbsp;&nbsp;&nbsp;&nbsp;   //" TokyoHigh: ", TokyoHigh, " TokyoLow: ", TokyoLow, " TokyoDiff: ", NormalizeDouble((TokyoHigh-TokyoLow),5),<br>&nbsp;&nbsp;&nbsp;&nbsp;   //" LondonHigh: ", LondonHigh, " LondonLow: ", LondonLow, " LondonDiff: ", NormalizeDouble((LondonHigh-LondonLow),5),<br>&nbsp;&nbsp;&nbsp;&nbsp;   //" NYHigh: ", NYHigh, " NYLow: ", NYLow, " NYDiff: ", NormalizeDouble((NYHigh-NYLow),5));&nbsp;&nbsp;&nbsp;&nbsp;   <br>&nbsp;&nbsp;&nbsp;&nbsp;  //}<br>  } //OnTick Ends<br>  <br>////////////////////////////////////////<br><br>void HighLow(double &high, double &low) //sets low and high for entire day<br>   {<br>&nbsp;&nbsp;&nbsp;&nbsp; if(BarHigh(1) > high)<br>&nbsp;&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;high = BarHigh(1);<br>&nbsp;&nbsp;&nbsp;&nbsp;   }<br>&nbsp;&nbsp;&nbsp;&nbsp; if(BarLow(1) < low)<br>&nbsp;&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;low = BarLow(1);<br>&nbsp;&nbsp;&nbsp;&nbsp;   }<br>   }<br><br>////////////////////////////////////////<br><br>void PivotPointDetection()<br>   {&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;   if(BarClose(1) < BarOpen(1)) //if previous bar was red<br>&nbsp;&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(BarHigh(1) == DayHigh || BarHigh(2) == DayHigh || BarHigh(3) == DayHigh) //if any of the three previous bars are equal to the DayHigh<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if(ArraySize(HighPivotPoints) == 0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ArrayResize(HighPivotPoints, ArraySize(HighPivotPoints)+1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HighPivotPoints[0] = DayHigh;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if(HighPivotPoints[ArraySize(HighPivotPoints)-1] != DayHigh)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ArrayResize(HighPivotPoints, ArraySize(HighPivotPoints)+1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HighPivotPoints[ArraySize(HighPivotPoints)-1] = DayHigh;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   for(int i=0;i<ArraySize(HighPivotPoints);i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Print("HighPivotPoints: ", HighPivotPoints[i]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>&nbsp;&nbsp;&nbsp;&nbsp;   }<br>&nbsp;&nbsp;&nbsp;&nbsp;   if(BarClose(1) > BarOpen(1)) //if previous bar was green<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if(BarLow(1) == DayLow || BarLow(2) == DayLow || BarLow(3) == DayLow)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(ArraySize(LowPivotPoints) == 0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ArrayResize(LowPivotPoints, ArraySize(LowPivotPoints)+1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LowPivotPoints[0] = DayLow;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if(LowPivotPoints[ArraySize(LowPivotPoints)-1] != DayLow)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ArrayResize(LowPivotPoints, ArraySize(LowPivotPoints)+1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LowPivotPoints[ArraySize(LowPivotPoints)-1] = DayLow;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int i=0;i<ArraySize(LowPivotPoints);i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Print("LowPivotPoints: ", LowPivotPoints[i]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;  } // Pivot point detection ends<br><br>////////////////////////////////////////<br><br>void BreakOut(bool &flagup, bool &flagdown, double high, double low, double &bohigh, double &bolow)<br>   {<br>&nbsp;&nbsp;&nbsp;&nbsp;  //Print("London high : ", high);<br>   <br>&nbsp;&nbsp;&nbsp;&nbsp;  if(BarClose(1) > high*InpBreakOutMult)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flagup = true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bohigh = BarHigh(1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;  <br>&nbsp;&nbsp;&nbsp;&nbsp;  if(BarClose(1) < 2*low-(low*InpBreakOutMult))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flagdown = true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bolow = BarLow(1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>   } <br><br>////////////////////////////////////////<br>   <br>void ReTraceReady(bool &retraceactivate, int dayminutes, int number, int &timer)<br>   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(timer == 0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   timer = (int)MathFloor(dayminutes/number);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(timer != (int)MathFloor(dayminutes/number))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   timer = (int)MathFloor(dayminutes/number);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   retraceactivate = true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>   }<br>////////////////////////////////////////<br><br>void ReTrace(double &high, double &low, bool &bouflag, bool &bodflag, bool &rtflag, bool &retraceactivate, int &timer, double &breakouthigh, double &breakoutlow) <br>   {   <br>&nbsp;&nbsp;&nbsp;&nbsp;double BOUpHighRetraceLim = high*InpOuterReTraceMult;<br>&nbsp;&nbsp;&nbsp;&nbsp;double BOUpLowRetraceLim = 2*high - high*InpInnerReTraceMult;<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;double BODownHighRetraceLim = low*InpInnerReTraceMult;<br>&nbsp;&nbsp;&nbsp;&nbsp;double BODownLowRetraceLim = 2*low - low*InpOuterReTraceMult; <br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;//Print("PrevBarLow: ", PrevBarLow, " BOUpHighRetraceLim: ", BOUpHighRetraceLim, " BOUpLowRetraceLim: ", BOUpLowRetraceLim);<br>&nbsp;&nbsp;&nbsp;&nbsp;//Print("PrevBarHigh: ", PrevBarHigh, " BODownHighRetraceLim: ", BODownHighRetraceLim, " BODownLowRetraceLim: ", BODownLowRetraceLim);<br>&nbsp;&nbsp;&nbsp;&nbsp;if(bouflag)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;   if(BarHigh(1) > breakouthigh)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  breakouthigh = BarHigh(1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;   if(BarLow(1) < BOUpLowRetraceLim && BarClose(1) < BarClose(2))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  bouflag = false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  rtflag = false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  retraceactivate = false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  timer = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  breakouthigh = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;   if(BarLow(1) <= BOUpHighRetraceLim && BarLow(1) >= BOUpLowRetraceLim)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  rtflag = true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;if(bodflag)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;   if(breakoutlow < BarLow(1))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  breakoutlow = BarLow(1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;   if(BarHigh(1) > BODownHighRetraceLim && BarClose(1) > BarClose(2))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  bodflag = false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  rtflag = false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  retraceactivate = false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  timer = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  breakoutlow = 100000;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;   if(BarHigh(1) >= BODownLowRetraceLim && BarHigh(1) <= BODownHighRetraceLim)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  rtflag = true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>   }<br><br>////////////////////////////////////////<br><br>void DSChecker() //daylight savings checker for NY session vs UTC + 2<br>{<br>  if(DayMQL4() == 1 && HourMQL4() == 0) //resets SundayCount to 0 at the very start of the month. Needed for the November section.<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp; SundayCount = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>   if(DayOfWeekMQL4() == 1 && HourMQL4() == 1 && (MonthMQL4() ==3 || MonthMQL4() == 10 || MonthMQL4() == 11)) //Actual count occurs on Monday morning, as FX market is inactive on Sunday. Only checks March, October and November<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp; if(MathMod(DayMQL4(), 7) == 0) // if the month starts on a Tuesday<br>&nbsp;&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SundayCount = (int)MathFloor(DayMQL4()/7);<br>&nbsp;&nbsp;&nbsp;&nbsp;   }<br>&nbsp;&nbsp;&nbsp;&nbsp; else if(MathMod(DayMQL4()-1, 7) == 0) //if the month starts on a Sunday<br>&nbsp;&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SundayCount = DayMQL4()/7;<br>&nbsp;&nbsp;&nbsp;&nbsp;   }<br>&nbsp;&nbsp;&nbsp;&nbsp; else if(MathMod(DayMQL4()-1, 7) != 0) //if the month doesn't start on a Sunday or Tuesday<br>&nbsp;&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SundayCount = (int)MathFloor(DayMQL4()/7)+1;<br>&nbsp;&nbsp;&nbsp;&nbsp;   }<br> //&nbsp;&nbsp;&nbsp;&nbsp;Print("Sunday Count: ", SundayCount);<br>&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp; if(SundayCount == 1 && (MonthMQL4() == 3 || MonthMQL4() == 10)) //This function is only intended for March and October (both 31 days). MaxSundays won't change outside of this, and will likely be wrong for other months.<br>&nbsp;&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(DayMQL4() >= 2 && DayMQL4() <=4)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   MaxSundays = 5;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   MaxSundays = 4;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>&nbsp;&nbsp;&nbsp;&nbsp;   }<br>//&nbsp;&nbsp;&nbsp;&nbsp; Print("Max Sundays: ", MaxSundays);<br>&nbsp;&nbsp;&nbsp;&nbsp; if(MonthMQL4() == 3 && SundayCount >= 2)<br>&nbsp;&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(SundayCount < MaxSundays)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   DSDifference = true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(SundayCount >= MaxSundays)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   DSDifference = false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>&nbsp;&nbsp;&nbsp;&nbsp;   }<br>&nbsp;&nbsp;&nbsp;&nbsp; if(MonthMQL4() == 10 && SundayCount >= MaxSundays)<br>&nbsp;&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DSDifference = true;<br>&nbsp;&nbsp;&nbsp;&nbsp;   }<br>&nbsp;&nbsp;&nbsp;&nbsp; if(MonthMQL4() == 11 && SundayCount < 1)<br>&nbsp;&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DSDifference = true;<br>&nbsp;&nbsp;&nbsp;&nbsp;   }<br>&nbsp;&nbsp;&nbsp;&nbsp; if(MonthMQL4() == 11 && SundayCount >= 1)<br>&nbsp;&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DSDifference = false;<br>&nbsp;&nbsp;&nbsp;&nbsp;   }<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>////////////////////////////////////////<br><br>void HighLowResetter()<br>   {<br>   if(HourMQL4() < 2)<br>&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;  DayHigh = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;  DayLow = 100000;<br>&nbsp;&nbsp;&nbsp;&nbsp;  TokyoHigh = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;  TokyoLow = 100000;<br>&nbsp;&nbsp;&nbsp;&nbsp;  LondonHigh = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;  LondonLow = 100000;<br>&nbsp;&nbsp;&nbsp;&nbsp;  NYHigh = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;  NYLow = 100000; <br>&nbsp;&nbsp;&nbsp;&nbsp;  ArrayFree(HighPivotPoints);<br>&nbsp;&nbsp;&nbsp;&nbsp;  ArrayFree(LowPivotPoints);<br>&nbsp;&nbsp;&nbsp;&nbsp;  PivotReTraceFlag = false;<br>&nbsp;&nbsp;&nbsp;&nbsp;  PivotDirection = None;<br>&nbsp;&nbsp;&nbsp;&nbsp;  BreakOutUpFlag = false;<br>&nbsp;&nbsp;&nbsp;&nbsp;  BreakOutDownFlag = false;<br>&nbsp;&nbsp;&nbsp;&nbsp;  ReTraceFlag = false;<br>&nbsp;&nbsp;&nbsp;&nbsp;  ReTraceActivate = false;<br>&nbsp;&nbsp;&nbsp;&nbsp;  Timer = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;  BreakOutHigh = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;  BreakOutLow = 100000;<br>&nbsp;&nbsp;&nbsp;&nbsp; }<br>   }<br>   <br>////////////////////////////////////////   <br><br>   void CloseAll()<br>&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;  bool success = false;<br>&nbsp;&nbsp;&nbsp;&nbsp;  for(int i = PositionsTotal() - 1; i >= 0; i--)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(!PositionGetTicket(i))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(PositionGetString(POSITION_SYMBOL) == Symbol())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success = Trader.PositionClose(PositionGetTicket(i));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>////////////////////////////////////////   <br><br>double BarHigh(int period)<br>   {<br>   return iHigh(_Symbol, PERIOD_CURRENT, period);<br>   }<br><br>////////////////////////////////////////  <br>   <br>double BarLow(int period)<br>   {<br>   return iLow(_Symbol, PERIOD_CURRENT, period);<br>   }<br><br>////////////////////////////////////////  <br>   <br>double BarClose(int period)<br>   {<br>   return iClose(_Symbol, PERIOD_CURRENT, period);<br>   }<br>   <br>////////////////////////////////////////  <br>   <br>double BarOpen(int period)<br>   {<br>   return iOpen(_Symbol, PERIOD_CURRENT, period);<br>   }<br><br>////////////////////////////////////////   <br><br>   int MonthMQL4()<br>&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;  MqlDateTime tm;<br>&nbsp;&nbsp;&nbsp;&nbsp;  TimeCurrent(tm);<br>&nbsp;&nbsp;&nbsp;&nbsp;  return(tm.mon);<br>&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>////////////////////////////////////////<br><br>   int DayMQL4()<br>&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;  MqlDateTime tm;<br>&nbsp;&nbsp;&nbsp;&nbsp;  TimeCurrent(tm);<br>&nbsp;&nbsp;&nbsp;&nbsp;  return(tm.day);<br>&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp; <br>////////////////////////////////////////<br>&nbsp;&nbsp;&nbsp;&nbsp; <br>  int HourMQL4()<br>&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;  MqlDateTime tm;<br>&nbsp;&nbsp;&nbsp;&nbsp;  TimeCurrent(tm);<br>&nbsp;&nbsp;&nbsp;&nbsp;  return(tm.hour);<br>&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>////////////////////////////////////////<br><br>   int MinuteMQL4()<br>&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;  MqlDateTime tm;<br>&nbsp;&nbsp;&nbsp;&nbsp;  TimeCurrent(tm);<br>&nbsp;&nbsp;&nbsp;&nbsp;  return(tm.min);<br>&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>/////////////////////////////////////////<br><br>   int SecondsMQL4()<br>&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;  MqlDateTime tm;<br>&nbsp;&nbsp;&nbsp;&nbsp;  TimeCurrent(tm);<br>&nbsp;&nbsp;&nbsp;&nbsp;  return(tm.sec);<br>&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp; <br>////////////////////////////////////////<br><br>   int DayOfWeekMQL4()<br>&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;  MqlDateTime tm;<br>&nbsp;&nbsp;&nbsp;&nbsp;  TimeCurrent(tm);<br>&nbsp;&nbsp;&nbsp;&nbsp;  return(tm.day_of_week);<br>&nbsp;&nbsp;&nbsp;&nbsp; }
	</p>
	
	<script>
	/* function Toggle() {
		var x = document.getElementById("pycode");
		if (x.style.display === "none") 
			{x.style.display = "block";} 
		else {x.style.display = "none"; }} 
		*/
		
	function Copy() {
		const copyText = document.getElementById("pycode").innerText; 
		navigator.clipboard.writeText(copyText);}
	</script>
</div>
</main>
</body>
</html>

